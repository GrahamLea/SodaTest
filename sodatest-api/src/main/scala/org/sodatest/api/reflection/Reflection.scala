/*
 * Copyright (c) 2010-2011 Belmont Technology Pty Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.sodatest.api { package reflection {

import _root_.java.lang.reflect._
import collection.immutable.Map
import org.sodatest.coercion.{CoercionRegister, Coercion}

/**
 * [[org.sodatest.api.SodaFixture]] base class that supports the discovery of [[org.sodatest.api.SodaEvent]]s
 * and [[org.sodatest.api.SodaReport]]s by reflecting on the subclass' functions.
 *
 * ReflectiveSodaFixture is probably the easiest way to implement the [[org.sodatest.api.SodaFixture]] trait.
 * Simply extend this trait and then define in the subclass public functions that have no parameters
 * and which return either a [[org.sodatest.api.SodaEvent]] or [[org.sodatest.api.SodaReport]] as required.
 * ReflectiveSodaFixture will canonize the incoming Event or Report name and then discover and invoke
 * a function on the subclass that has a name which, when also canonized, matches the Event or
 * Report name.
 *
 * (Names in SodaTest are canonized by removing all non-alpha-numeric characters and
 * converting all alpha characters to lower-case. e.g. canonized("Secret Report #2") -> "secretreport2")
 *
 * <b>Example</b>
 * {{{
 * class MyFixutre extends ReflectiveSodaFixture {
 *   def secretReport2: SodaReport = new SecretReport2()
 * }
 * }}}
 */
trait ReflectiveSodaFixture extends SodaFixture {
  import ReflectionUtil._

  /**
   * Creates a SodaEvent by reflecting on this SodaFixture to find a function whose canonized
   * name is equivalent to the canonized version of the specified name.
   */
  def createEvent(name: String): Option[SodaEvent] = invokeNoParamFunctionReturning(classOf[SodaEvent], name, this)

  /**
   * Creates a SodaReport by reflecting on this SodaFixture to find a function whose canonized
   * name is equivalent to the canonized version of the specified name.
   */
  def createReport(name: String): Option[SodaReport] = invokeNoParamFunctionReturning(classOf[SodaReport], name, this)
}

/**
 * [[org.sodatest.api.SodaEvent]] base class that supports the automatic binding of parameters to
 * public and strongly-typed vars, fields or setter methods.
 *
 * ReflectiveSodaEvent is probably the easiest way to implement the [[org.sodatest.api.SodaEvent]] trait.
 * It performs the tasks of both coercing and binding the string parameter values supplied in the parameter
 * map and allows the subclass to implement the `apply()` method that simply executes the Event.
 *
 * Parameters are discovered on subclasses by canonizing the names in the parameter map and looking
 * for members of the subclass which, when canonized, match the parameter name, according to the
 * following precedence:
 * <ol>
 *   <li>public Scala assignment methods, e.g. `def parameterName_$eq(_): Unit` (as generated by `var parameterName: T`)</li>
 *   <li>public setter methods, e.g. `public void setParameterName(T parameterName)`</li>
 *   <li>public fields, e.g. `public T parameterName`</li>
 * </ol>
 *
 * Note that when you declare a public `var` in Scala, the compiler automatically generates the
 * public assignment method.
 *
 * Once a parameter target is discovered, the parameter value is then coerced to the type of the
 * parameter using [[org.sodatest.coercion.Coercion$]]. Should the Event need to make custom [[org.sodatest.coercion.Coercion]]s
 * available to the coercion funciton, a [[org.sodatest.coercion.CoercionRegister]] field can be defined
 * within the Event which will be discovered and passed into the coercion.
 *
 * (Names in SodaTest are canonized by removing all non-alpha-numeric characters and
 * converting all alpha characters to lower-case. e.g. canonized("Secret Report #2") -> "secretreport2")
 *
 * <b>Example</b>
 * {{{
 * class MySodaEvent extends ReflectiveSodaEvent {
 *    var amount: BigDecimal = null
 *
 *   def apply(): Unit = {
 *     ... // Execute the event on the System, making use of 'amount'
 *   }
 * }
 * }}}
 */
trait ReflectiveSodaEvent extends SodaEvent {
  /**
   * Executes this Event on the System under test using the parameters that have been coerced and
   * bound by reflection into the members of this instance.
   */
  protected def apply(): Unit

  /**
   * Coerces and binds the parameters to this Event, then delegates to the [[apply()]] function.
   *
   * You can override this method if you want to perform some operation before the binding
   * or after the execution of the Event, calling super.apply(parameters) at the appropriate point.
   *
   */
  @throws(classOf[ParameterBindingException])
  def apply(parameters: Map[String, String]) = {
    ReflectionUtil.setByReflection(parameters, this)
    apply()
  }
}

/**
 * [[org.sodatest.api.SodaReport]] base class that supports the automatic binding of parameters to
 * public and strongly-typed vars, fields or setter methods.
 *
 * ReflectiveSodaReport is probably the easiest way to implement the [[org.sodatest.api.SodaReport]] trait.
 * It performs the tasks of both coercing and binding the string parameter values supplied in the parameter
 * map and allows the subclass to implement the `apply()` method that simply executes the Report and
 * returns the result as a `List[List[String]]`.
 *
 * Parameters are discovered on subclasses by canonizing the names in the parameter map and looking
 * for members of the subclass which, when canonized, match the parameter name, according to the
 * following precedence:
 * <ol>
 *   <li>public Scala assignment methods, e.g. `def parameterName_$eq(_): Unit` (as generated by `var parameterName: T`)</li>
 *   <li>public setter methods, e.g. `public void setParameterName(T parameterName)`</li>
 *   <li>public fields, e.g. `public T parameterName`</li>
 * </ol>
 *
 * Note that when you declare a public `var` in Scala, the compiler automatically generates the
 * public assignment method.
 *
 * Once a parameter target is discovered, the parameter value is then coerced to the type of the
 * parameter using [[org.sodatest.coercion.Coercion$]]. Should the Report need to make custom [[org.sodatest.coercion.Coercion]]s
 * available to the coercion funciton, a [[org.sodatest.coercion.CoercionRegister]] field can be defined
 * within the Report which will be discovered and passed into the coercion.
 *
 * (Names in SodaTest are canonized by removing all non-alpha-numeric characters and
 * converting all alpha characters to lower-case. e.g. canonized("Secret Report #2") -> "secretreport2")
 *
 * <b>Example</b>
 * {{{
 * class MySodaReport extends ReflectiveSodaReport {
 *    var amount: BigDecimal = null
 *
 *   def apply(): Unit = {
 *     ... // Execute the Report on the System, making use of 'amount'
 *   }
 * }
 * }}}
 */
trait ReflectiveSodaReport extends SodaReport {
  /**
   * Executes this Report on the System under test using the parameters that have been coerced and
   * bound by reflection into the members of this instance.
   *
   * @return a table representing the result of the Report as a Seq of Seqs of strings.
   * There is no requirement for the Seqs in the second dimension to have the same length as each other.
   */
  protected def apply(): Seq[Seq[String]]

  /**
   * Coerces and binds the parameters to this Report, then delegates to the [[apply()]] function.
   *
   * You can override this method if you want to perform some operation before the binding
   * or after the execution of the Report, calling super.apply(parameters) at the appropriate point.
   *
   */
  @throws(classOf[ParameterBindingException])
  def apply(parameters: Map[String, String]) = {
    ReflectionUtil.setByReflection(parameters, this)
    apply()
  }
}

private[reflection] object ReflectionUtil {

  def invokeNoParamFunctionReturning[A](requiredClass: Class[A], name: String, target: Object) = {
    val searchName = canonizedName(name)
    val candidateMethods = target.getClass.getMethods.filter(m => { canonizedName(m.getName) == searchName && m.getParameterTypes.isEmpty }).toList
    candidateMethods match {
      case Nil => None
      case method :: Nil => {
        if (requiredClass.isAssignableFrom(method.getReturnType)) {
          Some(method.invoke(target).asInstanceOf[A])
        } else {
          throw new IllegalStateException(method.getName + " does not return a " + requiredClass.getSimpleName) // TODO: Throw something more specific, catch above and handle
        }
      }
      case _ => throw new IllegalArgumentException(requiredClass.getSimpleName + " name '" + name + "' (canonized to '" + searchName + "') matches more than one method: " + candidateMethods) // TODO: Throw something more specific, catch above and handle
    }

  }

  @throws(classOf[ParameterBindingException])
  def setByReflection(parameters: Map[String, String], target: Object): Unit = {

    val coercionRegister = coercionRegisterIn(target)

    val assignmentMethodsMap: Map[String, Method] = target.getClass.getMethods.flatMap(m => m match {
          case AssignmentMethod(fieldName) => Some((canonizedName(fieldName), m))
          case _ => None
    }) toMap

    val fieldsMap: Map[String, Field] = target.getClass.getFields.toList.map(f => (canonizedName(f.getName), f)).toMap

    val bindFailures: Iterable[Option[ParameterBindFailure]] = for (val (parameterName, parameterValue) <- parameters) yield {
      val canonizedParameterName: String = canonizedName(parameterName)
      assignmentMethodsMap.get(canonizedParameterName) match {
        case Some(method) => {
          method.setAccessible(true)
          try {
            method.invoke(target, Coercion.coerce(parameterValue, getSingleParameterTypeFrom(method), coercionRegister).asInstanceOf[Object])
            None
          }
          catch {
            case e => Some(new ParameterBindFailure(parameterName, parameterValue, e.toString, Some(e)))
          }
        }
        case None => {
          fieldsMap.get(canonizedParameterName) match {
            case Some(field) => {
              field.setAccessible(true)
              try {
                field.set(target, Coercion.coerce(parameterValue, field.getGenericType, coercionRegister).asInstanceOf[Object])
                None
              }
              catch {
                case e => Some(new ParameterBindFailure(parameterName, parameterValue, e.toString, Some(e)))
              }
            }
            case None => Some(new ParameterBindFailure(parameterName, parameterValue,
                            String.format("Parameter '%s' could not be found on %s (%s)", parameterName, target.getClass.getSimpleName, target.getClass.getPackage.getName)))
          }
        }
      }
    }

    bindFailures flatten match {
      case Nil => {}
      case failureList => throw new ParameterBindingException(failureList toList)
    }
  }

  private def coercionRegisterIn(target: Object) : Option[CoercionRegister] = {
    target.getClass.getDeclaredFields.toList
      .filter(field => classOf[CoercionRegister].isAssignableFrom(field.getType))
      .headOption match {
        case None => None
        case Some(f) => {
          f.setAccessible(true)
          Some(f.get(target).asInstanceOf[CoercionRegister])
        }
      }
  }

  def canonizedName(s: String) = s.toLowerCase.replaceAll("[^a-z0-9]", "")

  private def getSingleParameterTypeFrom(method: Method): Type = method.getGenericParameterTypes.toList match {
    case oneParameterType :: Nil => oneParameterType
    case _ => error("Method does not have one parameter: " + method)
  }

  private object AssignmentMethod {
    val scalaAssignMethodRegex = "^(.*)_\\$eq$".r
    val setterMethodRegex = "^set(.*)$".r

    def unapply(method: Method): Option[String] = method.getGenericParameterTypes.toList match {
      case oneParameterType :: Nil => method.getName match {
        case scalaAssignMethodRegex(fieldName) => Some(fieldName)
        case setterMethodRegex(fieldName) => Some(fieldName)
        case _ => None
      }
      case _ => None
    }
  }
}

}}